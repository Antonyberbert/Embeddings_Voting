---
title: "H1_climateact_emb_0.6"
output:
  html_document: default
  pdf_document: default
date: "Sys.Date()"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Install and load necessary packages
packages <- c("devtools","here","dplyr","tidyverse","readxl","writexl","hunspell","text2vec","car","broom","lme4","RColorBrewer","rstatix","gridExtra","pROC","ggalluvial")
for (package in packages) {
  if (!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
}
lapply(packages,library, character.only=T)
```

```{r}
#Install and load embedR
if (!requireNamespace("embedR", quietly = TRUE)) {
    # If not installed, install it using devtools
    devtools::install_github("dwulff/embedR")
}

library("embedR")
```

```{r}
#read in final dataset
energyact_fin <- read_xlsx(here::here("data","energyact_final.xlsx"))

#read in matching dataset
matchids <- read.csv(here::here("data","Match_participantID.csv"),sep = ";")
matchids2 <- matchids %>% select(participantID.wave1,participantID.wave2)

# Select unique rows
matchids2 <- unique(matchids2)

#load embeddings as R object
embedding <- readRDS(here::here("data","embedding.rds"))
```

```{r,eval=F, echo=F}
#embed chatGPT list
#economy words
#embedR::er_set_tokens("cohere" = "x","huggingface"="x","openai" = "x")

#embedding_econ = er_embed(c("kosten","teuer","preis","arbeit","investition","wirtschaft","finanzierung","budget","ausgaben","steuern","subvention","gewinn","verlust","rendite","sparen","wettbewerb","verschuldung","einkommen","umsatz","markt"),api="cohere",model="embed-multilingual-v3.0")

#environmental prot words
#embedding_env = er_embed(c("umweltschutz","klimaschutz","dringend","notwendig","nachhaltigkeit","erneuerbar","ökologie","biodiversität","artenschutz","ressourcenschonung","emission","klimawandel","ökosystem","umweltbewusstsein","grüne energie","verschmutzung","zeitdruck","landschaftsschutz","naturschutz","tierschutz"),api="cohere",model="embed-multilingual-v3.0")
```

```{r,eval=F, echo=F}
#save embeddings as R object
#saveRDS(embedding_econ, here::here("data","embedding_econ.rds"))

#saveRDS(embedding_env, here::here("data","embedding_env.rds"))
```

```{r}
#Remove t1 and t2 from ID
energyact_fin <- energyact_fin %>%
  mutate(participantID = gsub("_t[1|2]$", "", participantID))
```

```{r}
# 2. Merge energyact_fin with matchids2 based on participantID of wave 1
# This will add the participantID.wave2 column to your energyact_fin dataframe for matching rows
energyact_fin <- energyact_fin %>%
  left_join(matchids2, by = c("participantID" = "participantID.wave1"))

# 3. Update the participantID for wave 1 participants with their corresponding wave 2 IDs
energyact_fin <- energyact_fin %>%
  mutate(participantID = if_else(wave == "t1" & !is.na(participantID.wave2), participantID.wave2, participantID))

# 4. Optionally, remove the temporary columns added during the merge
energyact_fin$participantID.wave1 <- NULL
energyact_fin$participantID.wave2 <- NULL

# Count the unique participantIDs in the dataframe
number_of_unique_ids <- energyact_fin %>% 
  summarise(unique_ids = n_distinct(participantID)) %>%
  pull(unique_ids)

# Print the number of unique participantIDs
print(number_of_unique_ids)
```

```{r}
set.seed(26)

calculate_max_similarity <- function(embedding_study, embedding_list) {
  # Calculate cosine similarity
  similarity_matrix <- sim2(embedding_study, embedding_list, method = "cosine")
  # Get the maximum similarity score for each word
  max_similarity <- apply(similarity_matrix, 1, max)
  return(max_similarity)
}
```

```{r}
#Load embeddings
embedding_econ <- readRDS(here::here("data","embedding_econ.rds"))

embedding_env <- readRDS(here::here("data","embedding_env.rds"))
# Creating a dataframe from the study embedding matrix
H1_df <- as.data.frame(embedding)

# Save the rownames as the first column in H1_df
H1_df$word <- rownames(H1_df)

# Reset the rownames of H1_df
rownames(H1_df) <- NULL



# Calculate max similarities
H1_df$max_similarity_econ <- calculate_max_similarity(embedding, embedding_econ)
H1_df$max_similarity_env <- calculate_max_similarity(embedding, embedding_env)
```

```{r}
#add similarity columns to energyact_fin
# Get the names of the last two columns
last_two_columns <- names(H1_df)[(ncol(H1_df)-1):ncol(H1_df)]

# Add the last two columns from H1_df to energyact_fin
energyact_fin[last_two_columns] <- H1_df[last_two_columns]
```

```{r}
energyact_fin <- energyact_fin %>%
  mutate(category = case_when(
    max_similarity_econ >= 0.6 & max_similarity_econ > max_similarity_env ~ "econ",
    max_similarity_env >= 0.6 & max_similarity_env > max_similarity_econ ~ "env",
    TRUE ~ "rest"
  ))
```

```{r}
# Assuming your original dataframe is named energyact_fin
# First, identify participants present in both waves
participants_in_both_waves <- energyact_fin %>%
  group_by(participantID) %>%
  filter(all(c("t1", "t2") %in% wave)) %>%
  ungroup() %>%
  select(participantID) %>%
  distinct()

# Now, filter the original dataframe to include only those participants
energyact_fin_both <- energyact_fin %>%
  semi_join(participants_in_both_waves, by = "participantID")

# Check the structure of the new dataframe
str(energyact_fin_both)
```
```{r}
#Manual categorization to check validity
# Step 1: Sample 50 random rows and select 'word' and 'category'
set.seed(30)

sampled_data <- energyact_fin_both %>%
  sample_n(50) %>%
  select(word, category)

# Step 2: Add a new column for manual categorization. Initially, it can be NA or a default value.
# Here I'm setting it to NA. You'll need to replace NAs with your manual categories.
sampled_data$manual_cat <- NA

# Export to CSV
write_xlsx(sampled_data %>% select(word, manual_cat), here("data","manual_cat.xlsx"))

# After manual editing, read the updated CSV back into R
#save the xlsx file as manual_cat_done!
# Make sure 'sampled_data' does not include a 'manual_cat' column
# Only select 'word' and 'category' columns to ensure this
sampled_data <- sampled_data %>% select(word, category)

# Now, read the manually categorized data, ensuring it has 'word' and 'manual_cat' columns
manual_cat <- read_xlsx(here("data", "manual_cat_done.xlsx"))

# Merge 'sampled_data' with 'manual_cat' by 'word', bringing in only the 'manual_cat' column from 'manual_cat'
sampled_data_with_manual_cat <- merge(sampled_data, manual_cat, by = "word")

# Calculate the match ratio
# This calculates the proportion of rows where 'category' matches 'manual_cat'
match_ratio <- mean(sampled_data_with_manual_cat$category == sampled_data_with_manual_cat$manual_cat, na.rm = TRUE)

# Print the match ratio
print(match_ratio)

# Filter and print non-matching rows
non_matching_rows <- sampled_data_with_manual_cat[sampled_data_with_manual_cat$category != sampled_data_with_manual_cat$manual_cat, ]
print(non_matching_rows)
```


```{r}
#Visualize similarity distribution
#First create ordered df
energyact_fin_ordered_econ_both <- energyact_fin_both[order(-energyact_fin_both$max_similarity_econ), ]

#Calculate median similarity
median_similarity_econ_both <- median(energyact_fin_ordered_econ_both$max_similarity_econ, na.rm = TRUE)

# Create the plot
similarity_econ_both <- ggplot(energyact_fin_ordered_econ_both, aes(x = reorder(row.names(energyact_fin_ordered_econ_both), -max_similarity_econ), y = max_similarity_econ)) +
  geom_hline(yintercept = median_similarity_econ_both, linetype = "dashed", color = "blue") +
  geom_point() +
  #theme(axis.text.x = element_blank()) +  # Hide x-axis text for legibility
  labs(x = "Words", y = "Max Similarity to Economy", title = "Similarity Scores for Economy Category") +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05)) +  # Set y-axis breaks
  theme_classic()

ggsave(here::here("plot","similarity_dis","similarity_dis","similarity_econ_both.png"), similarity_econ_both, width = 10, height = 8, dpi = 300,bg="transparent")
```

```{r}
# Create ordered dataframe based on max_similarity_env
energyact_fin_ordered_env_both <- energyact_fin_both[order(-energyact_fin_both$max_similarity_env), ]

# Calculate median similarity for environmental protection
median_similarity_env_both <- median(energyact_fin_ordered_env_both$max_similarity_env, na.rm = TRUE)

# Create the plot for environmental protection similarity
similarity_env_both <- ggplot(energyact_fin_ordered_env_both, aes(x = reorder(row.names(energyact_fin_ordered_env_both), -max_similarity_env), y = max_similarity_env)) +
  geom_hline(yintercept = median_similarity_env_both, linetype = "dashed", color = "blue") +
  geom_point() +
  # theme(axis.text.x = element_blank()) +  # Optionally hide x-axis text for legibility
  labs(x = "Words", y = "Max Similarity to Environmental Protection", title = "Similarity Scores for Environmental Protection Category") +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05)) +  # Set y-axis breaks
  theme_classic()

ggsave(here::here("plot","similarity_dis","similarity_dis","similarity_env_both.png"), similarity_env_both, width = 10, height = 8, dpi = 300,bg="transparent")
```

```{r}
# Combine the plots side by side
combined_plot <- grid.arrange(similarity_econ_both, similarity_env_both, ncol = 2)

# Save the combined plot
ggsave(here::here("plot","similarity_dis","similarity_dis","combined_plot.png"), plot = combined_plot, width = 20, height = 8, dpi = 300, bg = "transparent")
```
```{r}
# Create a combined data frame with a column for the category and the max similarity
combined_similarity_data <- data.frame(
  entry = c(1:length(energyact_fin_ordered_econ_both$max_similarity_econ), 
            1:length(energyact_fin_ordered_env_both$max_similarity_env)),
  max_similarity = c(energyact_fin_ordered_econ_both$max_similarity_econ, 
                     energyact_fin_ordered_env_both$max_similarity_env),
  category = rep(c("Economy", "Environmental Protection"), 
                 times = c(length(energyact_fin_ordered_econ_both$max_similarity_econ), 
                           length(energyact_fin_ordered_env_both$max_similarity_env)))
)

# Plot
combined_similarity_plot <- ggplot(combined_similarity_data, aes(x = entry, y = max_similarity, color = category)) +
  geom_point() +
  geom_hline(yintercept = median(energyact_fin_ordered_econ_both$max_similarity_econ, na.rm = TRUE), 
             linetype = "dashed", color = "#56B4E9") +
  geom_hline(yintercept = median(energyact_fin_ordered_env_both$max_similarity_env, na.rm = TRUE), 
             linetype = "dashed", color = "#E69F00") +
  scale_color_manual(values = c("Economy" = "#56B4E9", "Environmental Protection" = "#E69F00")) +
  labs(title = "Similarity Distribution", x = "Entries", y = "Max Similarity") +
  theme_classic() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.title = element_blank(), legend.position = "bottom") +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05))

# Print the plot
print(combined_similarity_plot)


# Save the plot
ggsave(here::here("plot","similarity_dis","similarity_dis","combined_similarity_distribution.png"), plot = combined_similarity_plot, width = 10, height = 8, dpi = 300, bg = "transparent")

```

```{r}
#Facet plot by intendedVote
# Adjust the combined data frame creation
combined_similarity_data_facet <- data.frame(
  entry = c(1:length(energyact_fin_ordered_econ_both$max_similarity_econ), 
            1:length(energyact_fin_ordered_env_both$max_similarity_env)),
  max_similarity = c(energyact_fin_ordered_econ_both$max_similarity_econ, 
                     energyact_fin_ordered_env_both$max_similarity_env),
  category = rep(c("Economy", "Environmental Protection"), 
                 times = c(length(energyact_fin_ordered_econ_both$max_similarity_econ), 
                           length(energyact_fin_ordered_env_both$max_similarity_env))),
  intendedVote = c(energyact_fin_ordered_econ_both$intendedVote, 
                   energyact_fin_ordered_env_both$intendedVote) # Assuming intendedVote is available in both data frames
)

# First, calculate medians for each combination of category and intendedVote
medians_by_vote_and_category <- combined_similarity_data_facet %>%
  group_by(category, intendedVote) %>%
  summarise(median_value = median(max_similarity, na.rm = TRUE))

# Updated geom_text to avoid using 'entry'
combined_similarity_plot_facet <- ggplot(combined_similarity_data_facet, aes(x = entry, y = max_similarity, color = category)) +
  geom_point() +
  geom_hline(data = medians_by_vote_and_category, aes(yintercept = median_value, color = category), linetype = "dashed") +
  scale_color_manual(values = c("Economy" = "#56B4E9", "Environmental Protection" = "#E69F00")) +
  labs(title = "Similarity Distribution by Intended Vote", x = "Entries", y = "Max Similarity") +
  theme_classic() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.title = element_blank(), legend.position = "bottom",
        axis.text.y = element_text(color = "black")) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~intendedVote)

# Print the plot
print(combined_similarity_plot_facet)

# Save the plot
ggsave(here::here("plot","similarity_dis","similarity_dis","combined_similarity_plot_facet.png"), plot = combined_similarity_plot_facet, width = 10, height = 8, dpi = 600, bg = "transparent")

```


```{r}
# Calculate the count of each category per participant
category_counts <- energyact_fin_both %>%
  group_by(participantID, category) %>%
  summarise(count = n(), .groups = 'drop')

# Calculate the total entries per participant
total_counts <- energyact_fin_both %>%
  group_by(participantID) %>%
  summarise(total = n(), .groups = 'drop')

# Merge and calculate proportions
proportions_df <- left_join(category_counts, total_counts, by = "participantID") %>%
  mutate(proportion = count / total) %>%
  select(participantID, category, proportion)

# Pivot wider to have separate columns for each category
proportions_across <- proportions_df %>%
  pivot_wider(names_from = category, values_from = proportion, values_fill = list(proportion = 0))
```

```{r}
#!!!!!!!!!!!!!!!!!!!!!!!!!!
#Some participants changed their vote from t1 to t2. How should we consider this in the analysis?
#This means, that when analysing changes across both time points, we have more rows than participants (293 instead of 254).

#Here I calculated the analyses with 293 rows.

# Join the proportions with intendedVote
energyact_fin_summary <- energyact_fin_both %>%
  select(participantID, intendedVote) %>%
  distinct() %>%
  left_join(proportions_across, by = "participantID")

# Calculate mean and SD of proportions by intendedVote
descriptive_stats <- energyact_fin_summary %>%
  group_by(intendedVote) %>%
  summarise(across(c(econ, env, rest), list(mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE))))

print(descriptive_stats)
```
```{r}
#Creating plot showcasing descriptive results for econ across wave per vote for 3 thresholds
# Data
data <- data.frame(
  Threshold = factor(rep(c("0.5", "0.6", "0.7"), each = 2)),
  Vote = rep(c("no", "yes"), times = 3),
  Mean = c(0.41, 0.39, 0.21, 0.21, 0.09, 0.09),
  SD = c(0.17, 0.17, 0.13, 0.13, 0.08, 0.08)
)

# Create a text label for mean (sd)
data$label <- paste(data$Mean, "(", data$SD, ")", sep = "")

# Get colorblind-friendly palette
colors <- brewer.pal(6, "Dark2")

# Prepare a combined category for the legend
data$Category <- with(data, paste(Threshold, Vote, sep = "_"))

# Correct order for the legend
legend_order <- c("0.5_no", "0.6_no", "0.7_no", "0.5_yes", "0.6_yes", "0.7_yes")

# Plot
desc_across_vote_thresholds_econ <- ggplot(data, aes(x = Vote, y = Mean, fill = Category)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = 0.2, position = position_dodge(0.9)) +
  geom_text(aes(label = label, y = Mean + SD), vjust = -0.5, position = position_dodge(0.9)) +
  scale_fill_manual(values = colors, breaks = legend_order) +
   scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Adjust the y-axis range
  facet_wrap(~Threshold, scales = "free_x", ncol = 3) +
  labs(title = "Mean and Standard Deviation of Economy Proportion, by Threshold and Intended Vote",
       x = "Voting Intention by Threshold", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 0, hjust = 1),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(nrow = 3, ncol = 2)) # Adjusts the legend to have 3 rows and 2 columns

# Print the plot
print(desc_across_vote_thresholds_econ)

ggsave(here::here("plot","desc_across_vote_thresholds_econ.png"), plot = desc_across_vote_thresholds_econ, width = 10, height = 10, dpi = 800, bg = "transparent")
```

```{r}
#Creating plot showcasing descriptive results for env across wave per vote for 3 thresholds
data <- data.frame(
  Threshold = factor(rep(c("0.5", "0.6", "0.7"), each = 2)),
  Vote = rep(c("no", "yes"), times = 3),
  Mean = c(0.49, 0.53, 0.25, 0.30, 0.13, 0.17),
  SD = c(0.17, 0.16, 0.16, 0.15, 0.11, 0.12)
)

# Create a text label for mean (sd)
data$label <- paste(data$Mean, " (", data$SD, ")", sep = "")

# Get colorblind-friendly palette
colors <- brewer.pal(6, "Dark2")

# Prepare a combined category for the legend
data$Category <- with(data, paste(Threshold, Vote, sep = "_"))

# Correct order for the legend
legend_order <- c("0.5_no", "0.6_no", "0.7_no", "0.5_yes", "0.6_yes", "0.7_yes")

# Plot
desc_across_vote_thresholds_env <- ggplot(data, aes(x = Vote, y = Mean, fill = Category)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = 0.2, position = position_dodge(0.9)) +
  geom_text(aes(label = label, y = Mean + SD), vjust = -0.5, position = position_dodge(0.9)) +
  scale_fill_manual(values = colors, breaks = legend_order) +
     scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Adjust the y-axis range
  facet_wrap(~Threshold, scales = "free_x", ncol = 3) +
  labs(title = "Mean and Standard Deviation of Environmental Protection Proportion, by Threshold and Intended Vote",
       x = "Voting Intention by Threshold", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 0, hjust = 1),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(nrow = 3, ncol = 2)) # Adjusts the legend to have 3 rows and 2 columns


# Print the plot
print(desc_across_vote_thresholds_env)

ggsave(here::here("plot","desc_across_vote_thresholds_env.png"), plot = desc_across_vote_thresholds_env, width = 10, height = 10, dpi = 800, bg = "transparent")
```

```{r}
#Calculating overall descriptive stats with only participants with consistent votes

# Create a summary of votes by participant and wave
votes_summary <- energyact_fin_both %>%
  group_by(participantID, wave) %>%
  summarise(intendedVote = unique(intendedVote), .groups = 'drop') %>%
  pivot_wider(names_from = wave, values_from = intendedVote, names_prefix = "vote_")

# Identify participants with the same vote in t1 and t2
consistent_vote_participants <- votes_summary %>%
  filter(vote_t1 == vote_t2) %>%
  select(participantID)

# Filter to keep only participants with consistent votes
energyact_fin_consistent <- energyact_fin_both %>%
  semi_join(consistent_vote_participants, by = "participantID")

# Calculate category counts and total counts as before
category_counts_cons <- energyact_fin_consistent %>%
  group_by(participantID, category) %>%
  summarise(count = n(), .groups = 'drop')

total_counts_cons <- energyact_fin_consistent %>%
  group_by(participantID) %>%
  summarise(total = n(), .groups = 'drop')

# Merge, calculate proportions, and pivot wider
proportions_cons <- left_join(category_counts_cons, total_counts_cons, by = "participantID") %>%
  mutate(proportion = count / total) %>%
  select(participantID, category, proportion)

proportions_wide_cons <- proportions_cons %>%
  pivot_wider(names_from = category, values_from = proportion, values_fill = list(proportion = 0))

# Join with intendedVote and calculate descriptive statistics
energyact_fin_summary_cons <- energyact_fin_consistent %>%
  select(participantID, intendedVote) %>%
  distinct() %>%
  left_join(proportions_wide_cons, by = "participantID")

descriptive_stats_cons <- energyact_fin_summary_cons %>%
  group_by(intendedVote) %>%
  summarise(across(c(econ, env, rest), list(mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE))))

print(descriptive_stats_cons)
```

```{r}
# Creating df with consistent participants that were present in both waves with proportions per category, wave, and vote
proportions_wave_cons <- energyact_fin_consistent %>%
  group_by(participantID, wave) %>%
  count(category) %>%
  ungroup() %>%
  group_by(participantID, wave) %>%
  mutate(total = sum(n)) %>%
  ungroup() %>%
  mutate(proportion = n / total) %>%
  select(participantID, wave, category, proportion)

# Pivot wider to have separate columns for each category, filling missing categories with zeros
proportions_category_separate_cons <- proportions_wave_cons %>%
  pivot_wider(names_from = category, values_from = proportion, values_fill = list(proportion = 0))

# Ensure joining with intendedVote to include it in the dataset
proportions_both_vote_wave_cons <- energyact_fin_consistent %>%
  select(participantID, wave, intendedVote) %>%
  distinct() %>%
  left_join(proportions_category_separate_cons, by = c("participantID", "wave"))
```

```{r}
#Wilcoxon sum rank test to check if econ and env are significantly different between including all participants or only those with consistent votes
# For the 'econ' category
econ_diff <- wilcox.test(
  x = energyact_fin_summary$econ,
  y = energyact_fin_summary_cons$econ,
  alternative = "two.sided"
)

# For the 'env' category
env_diff <- wilcox.test(
  x = energyact_fin_summary$env,
  y = energyact_fin_summary_cons$env,
  alternative = "two.sided"
)

# For the 'rest' category
rest_diff <- wilcox.test(
  x = energyact_fin_summary$rest,
  y = energyact_fin_summary_cons$rest,
  alternative = "two.sided"
)

# Print the results
print(list(
  econ_diff = econ_diff,
  env_diff = env_diff,
  rest_diff = rest_diff
))

#Not significantly different
```

```{r}
#Plotting different medians of econ and env for consistent and all voters
# Calculate medians for 'econ'
medians_econ <- energyact_fin_summary %>%
  summarise(median_econ_all = round(median(econ),2)) %>%
  bind_rows(energyact_fin_summary_cons %>%
              summarise(median_econ_cons = round(median(econ),2))) %>%
  mutate(x = factor(0:1))

# Calculate medians for 'env'
medians_env <- energyact_fin_summary %>%
  summarise(median_env_all = round(median(env),2)) %>%
  bind_rows(energyact_fin_summary_cons %>%
              summarise(median_env_cons = round(median(env),2))) %>%
  mutate(x = factor(0:1))

# Plot for the 'econ' category
diff_cons_all_econ <- ggplot() +
  geom_boxplot(data = energyact_fin_summary, aes(y = econ, x = factor(0), fill = "All Participants"), color = "black") +
  geom_boxplot(data = energyact_fin_summary_cons, aes(y = econ, x = factor(1), fill = "Consistent Votes"), color = "black") +
  geom_text(data = medians_econ, aes(x = x, y = ifelse(x == 0, median_econ_all, median_econ_cons), label = ifelse(x == 0, median_econ_all, median_econ_cons)), vjust = -0.5, color = "black") +
  scale_fill_manual(values = c("All Participants" = "#56B4E9", "Consistent Votes" = "#E69F00")) +
  labs(x = "", y = "Economic Ratings", title = "Economic Ratings: All Participants vs. Consistent Voters") +
  theme_minimal() +
  theme(legend.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.position = "bottom") +
  scale_x_discrete(labels = c("All Participants", "Consistent Votes"))

#Save the econ plot
ggsave(here::here("plot","H1_0.6","diff_cons_all_econ.png"), diff_cons_all_econ, width = 10, height = 8, dpi = 300,bg="transparent")

# Plot for the 'env' category
diff_cons_all_env <- ggplot() +
  geom_boxplot(data = energyact_fin_summary, aes(y = env, x = factor(0), fill = "All Participants"), color = "black") +
  geom_boxplot(data = energyact_fin_summary_cons, aes(y = env, x = factor(1), fill = "Consistent Votes"), color = "black") +
  geom_text(data = medians_env, aes(x = x, y = ifelse(x == 0, median_env_all, median_env_cons), label = ifelse(x == 0, median_env_all, median_env_cons)), vjust = -0.5, color = "black") +
  scale_fill_manual(values = c("All Participants" = "#009E73", "Consistent Votes" = "#D55E00")) +
  labs(x = "", y = "Environmental Ratings", title = "Environmental Ratings: All Participants vs. Consistent Voters") +
  theme_minimal() +
  theme(legend.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.position = "bottom") +
  scale_x_discrete(labels = c("All Participants", "Consistent Votes"))

#Save the env plot
ggsave(here::here("plot","H1_0.6","diff_cons_all_env.png"), diff_cons_all_env, width = 10, height = 8, dpi = 300,bg="transparent")
```

```{r}
# Creating df with participants that were present in both waves with proportions per category, wave, and vote
proportions_wave <- energyact_fin_both %>%
  group_by(participantID, wave) %>%
  count(category) %>%
  ungroup() %>%
  group_by(participantID, wave) %>%
  mutate(total = sum(n)) %>%
  ungroup() %>%
  mutate(proportion = n / total) %>%
  select(participantID, wave, category, proportion)

# Pivot wider to have separate columns for each category, filling missing categories with zeros
proportions_category_separate <- proportions_wave %>%
  pivot_wider(names_from = category, values_from = proportion, values_fill = list(proportion = 0))

# Ensure joining with intendedVote to include it in the dataset
proportions_both_vote_wave <- energyact_fin_both %>%
  select(participantID, wave, intendedVote) %>%
  distinct() %>%
  left_join(proportions_category_separate, by = c("participantID", "wave"))
```

```{r}
# Calculate mean and SD by wave
summary_by_wave <- proportions_both_vote_wave %>%
  group_by(wave) %>%
  summarise(across(c(econ, env, rest), list(mean = ~mean(., na.rm = TRUE), 
                                            sd = ~sd(., na.rm = TRUE))))

print(summary_by_wave)
```

```{r}
# Calculate mean and SD by wave and intendedVote
summary_by_wave_vote <- proportions_both_vote_wave %>%
  group_by(wave, intendedVote) %>%
  summarise(across(c(econ, env, rest), list(mean = ~mean(., na.rm = TRUE), 
                                            sd = ~sd(., na.rm = TRUE))))

print(summary_by_wave_vote)
```

```{r}
# Calculate mean and SD by wave and intendedVote for consistent participants
summary_by_wave_vote_cons <- proportions_both_vote_wave_cons %>%
  group_by(wave, intendedVote) %>%
  summarise(across(c(econ, env, rest), list(mean = ~mean(., na.rm = TRUE), 
                                            sd = ~sd(., na.rm = TRUE))))

print(summary_by_wave_vote_cons)
```
```{r}
# Step 1: Identify participants that changed their vote from t1 to t2
participant_changes <- proportions_both_vote_wave %>%
  group_by(participantID) %>%
  filter(n() == 2) %>% # Ensure we have both t1 and t2 for each participant
  summarise(vote_change = n_distinct(intendedVote) > 1) %>%
  filter(vote_change) %>%
  select(participantID)

# Step 2: Create a dataframe with only those participants that changed their vote
changed_vote_df <- proportions_both_vote_wave %>%
  semi_join(participant_changes, by = "participantID")

# Step 3: Calculate mean and sd for participants based on intendedVote and wave
results <- changed_vote_df %>%
  group_by(wave, intendedVote) %>%
  summarise(mean_econ = mean(econ, na.rm = TRUE),
            sd_econ = sd(econ, na.rm = TRUE),
            mean_env = mean(env, na.rm = TRUE),
            sd_env = sd(env, na.rm = TRUE)) %>%
  ungroup()

# Display the results
print(results)
```

```{r}
#Barplot of voters that changed vote or stayed consistent showing mean and sd of ECONOMY proportion
# Data preparation
data <- data.frame(
  BarName = c("no_yes t1", "yes_no t1", "no t1", "yes t1",
              "no_yes t2", "yes_no t2", "no t2", "yes t2"),
  Wave = rep(c("t1", "t2"), each = 4),
  Mean = c(0.18, 0.16, 0.18, 0.20, 0.25, 0.27, 0.24, 0.22),
  SD = c(0.16, 0.14, 0.13, 0.16, 0.19, 0.20, 0.17, 0.15)
)

# Simplify BarName for color mapping (remove wave info)
data$SimpleBarName <- gsub(" t[12]", "", data$BarName)

# Add a label for the mean (sd)
data$label <- with(data, paste0(Mean, " (", SD, ")"))

# Choose colorblind-friendly colors
# Ensure there are enough colors for the unique SimpleBarNames
colors <- brewer.pal(n = length(unique(data$SimpleBarName)), name = "Set3")

# Create the plot
econ_subset_voters_barplot <- ggplot(data, aes(x = BarName, y = Mean, fill = SimpleBarName)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = 0.2, position = position_dodge(0.9)) +
  geom_text(aes(label = label, y = Mean + SD), vjust = -0.5, position = position_dodge(0.9)) +
  facet_wrap(~Wave, scales = "free_x") +
  scale_fill_manual(values = setNames(colors, unique(data$SimpleBarName))) +
  labs(title = "Mean and SD of Economy Proportion by Vote and Wave for Subset of Voters at 0.6 Threshold",
       x = "", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))

# Print the plot
print(econ_subset_voters_barplot)

ggsave(here::here("plot","H1_0.6","econ_subset_voters_barplot.png"), plot = econ_subset_voters_barplot, width = 10, height = 8, dpi = 300, bg = "transparent")
```

```{r}
#Barplot of voters that changed vote or stayed consistent showing mean and sd of ENV proportion
# Data preparation
data <- data.frame(
  BarName = c("no_yes t1", "yes_no t1", "no t1", "yes t1",
              "no_yes t2", "yes_no t2", "no t2", "yes t2"),
  Wave = rep(c("t1", "t2"), each = 4),
  Mean = c(0.26, 0.35, 0.26, 0.28, 0.29, 0.22, 0.21, 0.31),
  SD = c(0.22, 0.17, 0.19, 0.18, 0.21, 0.16, 0.17, 0.19)
)

# Simplify BarName for color mapping (remove wave info)
data$SimpleBarName <- gsub(" t[12]", "", data$BarName)

# Add a label for the mean (sd)
data$label <- with(data, paste0(Mean, " (", SD, ")"))

# Choose colorblind-friendly colors
# Ensure there are enough colors for the unique SimpleBarNames
colors <- brewer.pal(n = length(unique(data$SimpleBarName)), name = "Set3")

# Create the plot
env_subset_voters_barplot <- ggplot(data, aes(x = BarName, y = Mean, fill = SimpleBarName)) +
  geom_bar(stat = "identity", position = position_dodge(), color = "black") +
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), width = 0.2, position = position_dodge(0.9)) +
  geom_text(aes(label = label, y = Mean + SD), vjust = -0.5, position = position_dodge(0.9)) +
  facet_wrap(~Wave, scales = "free_x") +
  scale_fill_manual(values = setNames(colors, unique(data$SimpleBarName))) +
  labs(title = "Mean and SD of Environmental Protection Proportion by Vote and Wave for Subset of Voters at 0.6 Threshold",
       x = "", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))

# Print the plot
print(env_subset_voters_barplot)

ggsave(here::here("plot","env_subset_voters_barplot.png"), plot = env_subset_voters_barplot, width = 10, height = 8, dpi = 600, bg = "transparent")
```

```{r}
# Data frame with all the necessary information
data <- data.frame(
  Threshold = rep(c("0.5", "0.6", "0.7"), each = 4),
  Condition = rep(c("no", "yes"), times = 6),
  Type = rep(c("t1", "t2"), each = 2, times = 3),
  Mean = c(0.40, 0.37, 0.43, 0.40, 0.18, 0.19, 0.24, 0.22, 0.08, 0.09, 0.09, 0.09),
  SD = c(0.20, 0.22, 0.21, 0.20, 0.13, 0.16, 0.18, 0.16, 0.09, 0.10, 0.11, 0.09)
)

# Combine Threshold and Condition to a new variable
data$Group <- with(data, paste(Threshold, Condition, sep = "_"))

# Add a label for the mean (sd)
data$label <- with(data, paste0(Mean, " (", SD, ")"))

# Create a colorblind-friendly palette for "no" and "yes" conditions
colors <- brewer.pal(6, "Dark2")

legend_order <- c("0.5_no", "0.6_no", "0.7_no", "0.5_yes", "0.6_yes", "0.7_yes")

# Adjust the dodge width to ensure consistent spacing between bars and their labels
dodge_width <- 0.9

# Create the plot with the specified y-limits from 0 to 1
econ_wave_vote_threshold <- ggplot(data, aes(x = Type, y = Mean, fill = Group)) +
  geom_bar(stat = "identity", position = position_dodge(dodge_width), color = "black") +
  geom_errorbar(
    aes(ymin = pmax(Mean - SD, 0), ymax = pmin(Mean + SD, 1)), # Ensure error bars stay within 0 to 1
    width = 0.25,
    position = position_dodge(dodge_width)
  ) +
  geom_text(
    aes(label = label, y = pmin(Mean + SD, 1)), # Adjust text position to not exceed y of 1
    vjust = -0.5, size = 3.5,
    position = position_dodge(1)
  ) +
  scale_fill_manual(values = colors, breaks = legend_order) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Fixed limits from 0 to 1
  facet_wrap(~Threshold, scales = "free_x") +
  labs(title = "Mean and Standard Deviation of Economy Proportion by Vote, Wave, and Threshold",
       x = "Voting Intention by Wave and Threshold", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 0, hjust = 1),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(nrow = 3, ncol = 2))

# Print the plot
print(econ_wave_vote_threshold)

ggsave(here::here("plot","econ_wave_vote_threshold.png"), plot = econ_wave_vote_threshold, width = 10, height = 10, dpi = 1000, bg = "transparent")
```

```{r}
#Plot Mean and SD of Env Protection Proportion by Vote, Wave, and Threshold for All Participants
# Data frame with all the necessary information
data <- data.frame(
  Threshold = rep(c("0.5", "0.6", "0.7"), each = 4),
  Condition = rep(c("no", "yes"), times = 6),
  Type = rep(c("t1", "t2"), each = 2, times = 3),
  Mean = c(0.48, 0.54, 0.48, 0.53, 0.26, 0.29, 0.23, 0.30, 0.13, 0.17, 0.12, 0.17),
  SD = c(0.20, 0.21, 0.22, 0.19, 0.20, 0.18, 0.18, 0.19, 0.12, 0.15, 0.14, 0.15)
)

# Combine Threshold and Condition to a new variable
data$Group <- with(data, paste(Threshold, Condition, sep = "_"))

# Add a label for the mean (sd)
data$label <- with(data, paste0(Mean, " (", SD, ")"))

# Create a colorblind-friendly palette for "no" and "yes" conditions
colors <- brewer.pal(6, "Dark2")

legend_order <- c("0.5_no", "0.6_no", "0.7_no", "0.5_yes", "0.6_yes", "0.7_yes")

# Adjust the dodge width to ensure consistent spacing between bars and their labels
dodge_width <- 0.9

# Create the plot with the specified y-limits from 0 to 1
env_wave_vote_threshold <- ggplot(data, aes(x = Type, y = Mean, fill = Group)) +
  geom_bar(stat = "identity", position = position_dodge(dodge_width), color = "black") +
  geom_errorbar(
    aes(ymin = pmax(Mean - SD, 0), ymax = pmin(Mean + SD, 1)), # Ensure error bars stay within 0 to 1
    width = 0.25,
    position = position_dodge(dodge_width)
  ) +
  geom_text(
    aes(label = label, y = pmin(Mean + SD, 1)), # Adjust text position to not exceed y of 1
    vjust = -0.5, size = 3.5,
    position = position_dodge(1)
  ) +
  scale_fill_manual(values = colors, breaks = legend_order) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, by = 0.2)) + # Fixed limits from 0 to 1
  facet_wrap(~Threshold, scales = "free_x") +
  labs(title = "Mean and Standard Deviation of Environmental Protection Proportion by Vote, Wave, and Threshold",
       x = "Voting Intention by Wave and Threshold", y = "Mean Proportion") +
  theme_minimal() +
  theme(legend.title = element_blank(), legend.position = "bottom", axis.text.x = element_text(angle = 0, hjust = 1),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(nrow = 3, ncol = 2))

# Print the plot
print(env_wave_vote_threshold)

ggsave(here::here("plot","env_wave_vote_threshold.png"), plot = env_wave_vote_threshold, width = 10, height = 10, dpi = 1000, bg = "transparent")
```

```{r}
#Calculate how many participants changed their vote from t1 to t2
# Assuming proportions_both_vote_wave is your starting dataframe
# Filter for unique participantID-wave combinations
votes_comparison <- proportions_both_vote_wave %>%
  select(participantID, wave, intendedVote) %>%
  distinct() %>%
  pivot_wider(names_from = wave, values_from = intendedVote, names_prefix = "vote_")

# Ensure we're only considering participants who have votes for both t1 and t2
votes_comparison <- votes_comparison %>%
  filter(!is.na(vote_t1) & !is.na(vote_t2))

# Classify vote changes
vote_changes_summary <- votes_comparison %>%
  mutate(change_status = case_when(
    vote_t1 == 0 & vote_t2 == 1 ~ "0 to 1",
    vote_t1 == 1 & vote_t2 == 0 ~ "1 to 0",
    vote_t1 == 0 & vote_t2 == 0 ~ "Stable 0",
    vote_t1 == 1 & vote_t2 == 1 ~ "Stable 1"
  )) %>%
  count(change_status) %>%
  mutate(percentage = n / sum(n) * 100)

# Extend the vote_changes_summary to include broader categories
total_vote_changes_summary <- votes_comparison %>%
  mutate(changed = if_else(vote_t1 == vote_t2, "Not Changed", "Changed")) %>%
  count(changed) %>%
  mutate(percentage = n / sum(n) * 100)

print(total_vote_changes_summary)

print(vote_changes_summary)
```
```{r}
# Assuming votes_comparison is already loaded and contains participantID, vote_t1, vote_t2
# First, ensure that vote_t1 and vote_t2 are factors
votes_comparison$vote_t1 <- as.factor(votes_comparison$vote_t1)
votes_comparison$vote_t2 <- as.factor(votes_comparison$vote_t2)

# Prepare the data specifically for an alluvial plot
# We need to create a dataset that explicitly lists each transition between t1 and t2 votes
alluvial_data <- votes_comparison %>%
  count(vote_t1, vote_t2) %>%
  mutate(vote_t1 = as.character(vote_t1), 
         vote_t2 = as.character(vote_t2))

# Plotting
ggplot(alluvial_data,
       aes(axis1 = vote_t1, axis2 = vote_t2, y = n, label = n)) +
  geom_alluvium(aes(fill = vote_t1)) +
  geom_text(stat = "stratum", size = 3) +
  scale_x_discrete(limits = c("t1", "t2"), expand = c(0.1, 0.1)) +
  scale_fill_manual(values = c("0" = "steelblue", "1" = "seagreen")) +
  theme_minimal() +
  labs(title = "Voting Intention Changes from t1 to t2",
       x = "", y = "Count of Participants")
```
```{r}
# Assuming votes_comparison is already prepared with participantID, vote_t1, and vote_t2
# First, ensure that vote_t1 and vote_t2 are factors
votes_comparison <- votes_comparison %>%
  mutate(across(c(vote_t1, vote_t2), as.factor))

# Create a summary of vote changes with percentages
vote_changes_summary <- votes_comparison %>%
  mutate(
    change = case_when(
      vote_t1 == "0" & vote_t2 == "0" ~ "Consistent No",
      vote_t1 == "1" & vote_t2 == "1" ~ "Consistent Yes",
      vote_t1 == "0" & vote_t2 == "1" ~ "No to Yes",
      vote_t1 == "1" & vote_t2 == "0" ~ "Yes to No"
    )
  ) %>%
  count(change) %>%
  mutate(percentage = n / sum(n) * 100)

# Reorder the factor levels of change by the percentage in descending order for the legend
vote_changes_summary$change <- fct_reorder(vote_changes_summary$change, vote_changes_summary$percentage, .desc = TRUE)

# Create the pie chart with percentages
prop_voting_intention <- ggplot(vote_changes_summary, aes(x = "", y = percentage, fill = change)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  theme_void() +
  scale_fill_brewer(palette = "Set3", direction = -1) + # colorblind-friendly palette
  geom_text(aes(label = paste0(round(percentage, 1), "%")), position = position_stack(vjust = 0.5),
            size = 3) +
  labs(title = "Proportion of Changes in Voting Intention From T1 to T2",
       fill = "Voting Intention") +
  theme(legend.position = "right")  # Adjust legend position

# Display the plot
prop_voting_intention

ggsave(here::here("plot","H1_0.6","prop_voting_intention.png"),prop_voting_intention, width = 8, height = 8, dpi = 300,bg="transparent")
```


```{r}
#Plots of mean & standard error across both time points by vote

# Create a function to generate color-blind-friendly plots for econ and env by intendedVote
# Function to calculate mean and standard error
mean_se <- function(x) {
  se <- sd(x) / sqrt(length(x))
  return(c(y = mean(x), ymin = mean(x) - se, ymax = mean(x) + se))
}

# Function to generate color-blind-friendly plots for econ and env by intendedVote
plot_by_intendedVote <- function(data, variable_name) {
  p <- ggplot(data, aes(x = factor(intendedVote), y = !!as.symbol(variable_name), fill = factor(intendedVote))) +
    stat_summary(fun = "mean", geom = "bar", position = position_dodge(), color = "black") +
    stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(0.9), width = 0.25) +
    scale_fill_brewer(palette = "Set2", name = "Intended Vote", labels = c("0" = "No", "1" = "Yes")) +
    geom_text(
      aes(label = sprintf("%.2f (%.2f)", ..y.., ..ymax.. - ..y..)),
      stat = "summary",
      fun.data = mean_se,
      vjust = -4,
      position = position_dodge(0.9)
    ) +
    expand_limits(y = 0) +
    labs(x = "Intended Vote", y = "Mean Value", title = paste("Mean and SE of", variable_name, "by Intended Vote")) +
    theme_minimal(base_size = 12) +
    theme(legend.position = "bottom",
          axis.title.x = element_text(size = 12, face = "bold"),
          axis.title.y = element_text(size = 12, face = "bold"),
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          legend.title = element_text(size = 12))
  return(p)
}


# Generate plots and save them
# Plot for econ - all participants
mean_econ_vote_all <- plot_by_intendedVote(energyact_fin_summary, "econ")
ggsave(here::here("plot","H1_0.6","mean_econ_vote_all.png"), mean_econ_vote_all, width = 10, height = 8, dpi = 300,bg="transparent")

# Plot for env - all participants
mean_env_vote_all <- plot_by_intendedVote(energyact_fin_summary, "env")
ggsave(here::here("plot","H1_0.6","mean_env_vote_all.png"), mean_env_vote_all, width = 10, height = 8, dpi = 300,bg="transparent")

# Plot for econ - consistent participants
mean_econ_vote_cons <- plot_by_intendedVote(energyact_fin_summary_cons, "econ")
ggsave(here::here("plot","H1_0.6","mean_econ_vote_cons.png"), mean_econ_vote_cons, width = 10, height = 8, dpi = 300,bg="transparent")

# Plot for env - consistent participants
mean_env_votet_cons <- plot_by_intendedVote(energyact_fin_summary_cons, "env")
ggsave(here::here("plot","H1_0.6","mean_env_vote_cons.png"), mean_env_votet_cons, width = 10, height = 8, dpi = 300,bg="transparent")
```

```{r}
# Plotting mean & se by wave for all participants
agg_data <- proportions_both_vote_wave %>%
  group_by(wave) %>%
  summarise(mean_econ = mean(econ), se_econ = sd(econ) / sqrt(n())) %>%
  ungroup()

# Plot for Econ
mean_econ_wave_all <- ggplot(proportions_both_vote_wave, aes(x = wave, fill = wave)) +
  geom_bar(aes(y = econ, group = wave), position = position_dodge(width = 0.7), stat = "summary", fun = "mean") +
  geom_errorbar(aes(y = econ, group = wave, ymin = econ - sd(econ), ymax = econ + sd(econ)), position = position_dodge(width = 0.7), stat = "summary", fun.data = mean_se) +
  geom_text(data = agg_data, aes(x = wave, y = mean_econ, label = sprintf("%.2f (%.2f)", mean_econ, se_econ)), position = position_dodge(width = 0.7), vjust = -4) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Wave", y = "Econ", title = "Mean Econ by Wave with SE") +
  theme_minimal() +
  theme(legend.position = "none")

# Save the Econ plot
ggsave(here::here("plot","H1_0.6","mean_econ_wave_all.png"), mean_econ_wave_all, width = 10, height = 8, dpi = 300)

# Function to calculate mean and standard error
mean_se <- function(x) {
  se <- sd(x) / sqrt(length(x))
  return(c(y = mean(x), ymin = mean(x) - se, ymax = mean(x) + se))
}

# Compute the aggregated data for 'env'
agg_data_env <- proportions_both_vote_wave %>%
  group_by(wave) %>%
  summarise(mean_env = mean(env), se_env = sd(env) / sqrt(n()), .groups = 'drop')

# Plot for Env
mean_env_wave_all <- ggplot(proportions_both_vote_wave, aes(x = wave, fill = wave)) +
  geom_bar(aes(y = env, group = wave), position = position_dodge(width = 0.7), stat = "summary", fun = "mean") +
  geom_errorbar(aes(y = env, group = wave, ymin = env - sd(env), ymax = env + sd(env)), position = position_dodge(width = 0.7), stat = "summary", fun.data = mean_se) +
  geom_text(data = agg_data_env, aes(x = wave, y = mean_env, label = sprintf("%.2f (%.2f)", mean_env, se_env)), position = position_dodge(width = 0.7), vjust = -4) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Wave", y = "Env", title = "Mean Env by Wave with SE") +
  theme_minimal() +
  theme(legend.position = "none")

# Save the Env plot to the 'plot' directory with the name 'env_plot.png'
ggsave(here::here("plot","H1_0.6","mean_env_wave_all.png"), mean_env_wave_all, width = 10, height = 8, dpi = 300)
```

```{r}
# Plotting mean & se by wave for Consistent participants
agg_data_cons <- proportions_both_vote_wave_cons %>%
  group_by(wave) %>%
  summarise(mean_econ = mean(econ), se_econ = sd(econ) / sqrt(n())) %>%
  ungroup()

# Plot for Econ
mean_econ_wave_cons <- ggplot(proportions_both_vote_wave_cons, aes(x = wave, fill = wave)) +
  geom_bar(aes(y = econ, group = wave), position = position_dodge(width = 0.7), stat = "summary", fun = "mean") +
  geom_errorbar(aes(y = econ, group = wave, ymin = econ - sd(econ), ymax = econ + sd(econ)), position = position_dodge(width = 0.7), stat = "summary", fun.data = mean_se) +
  geom_text(data = agg_data_cons, aes(x = wave, y = mean_econ, label = sprintf("%.2f (%.2f)", mean_econ, se_econ)), position = position_dodge(width = 0.7), vjust = -4) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Wave", y = "Econ", title = "Mean Econ by Wave with SE for Consistent Participants") +
  theme_minimal() +
  theme(legend.position = "none")

# Save the Econ plot
ggsave(here::here("plot","H1_0.6","mean_econ_wave_cons.png"), mean_econ_wave_cons, width = 10, height = 8, dpi = 300)

# Function to calculate mean and standard error
mean_se <- function(x) {
  se <- sd(x) / sqrt(length(x))
  return(c(y = mean(x), ymin = mean(x) - se, ymax = mean(x) + se))
}

# Compute the aggregated data for 'env'
agg_data_env_cons <- proportions_both_vote_wave_cons %>%
  group_by(wave) %>%
  summarise(mean_env = mean(env), se_env = sd(env) / sqrt(n()), .groups = 'drop')

# Plot for Env
mean_env_wave_cons <- ggplot(proportions_both_vote_wave_cons, aes(x = wave, fill = wave)) +
  geom_bar(aes(y = env, group = wave), position = position_dodge(width = 0.7), stat = "summary", fun = "mean") +
  geom_errorbar(aes(y = env, group = wave, ymin = env - sd(env), ymax = env + sd(env)), position = position_dodge(width = 0.7), stat = "summary", fun.data = mean_se) +
  geom_text(data = agg_data_env_cons, aes(x = wave, y = mean_env, label = sprintf("%.2f (%.2f)", mean_env, se_env)), position = position_dodge(width = 0.7), vjust = -4) +
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05))) +
  labs(x = "Wave", y = "Env", title = "Mean Env by Wave with SE for Consistent Participants") +
  theme_minimal() +
  theme(legend.position = "none")

# Save the Env plot to the 'plot' directory with the name 'env_plot.png'
ggsave(here::here("plot","H1_0.6","mean_env_wave_cons.png"), mean_env_wave_cons, width = 10, height = 8, dpi = 300)
```


```{r}
#Plotting mean and SE by wave & vote for all participants

# Define the mean_se function if it's not already defined
mean_se <- function(x) {
  se <- sd(x) / sqrt(length(x))
  return(c(y = mean(x), ymin = mean(x) - se, ymax = mean(x) + se))
}

# Calculate the mean and standard error for env by intendedVote and wave
agg_data_env <- proportions_both_vote_wave %>%
  group_by(wave, intendedVote) %>%
  summarise(mean_env = mean(env), se_env = sd(env) / sqrt(n()), .groups = 'drop')

# Plot for env with mean and SE
mean_env_wave_vote_all <- ggplot(proportions_both_vote_wave, aes(x = factor(intendedVote), y = env, fill = factor(intendedVote))) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(width = 0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(width = 0.8), width = 0.25) +
  geom_text(data = agg_data_env, aes(x = factor(intendedVote), y = mean_env + se_env, label = sprintf("%.2f (%.2f)", mean_env, se_env)), 
            position = position_dodge(width = 0.8), vjust = -0.5, check_overlap = TRUE) +
  facet_wrap(~wave) +
  scale_fill_brewer(palette = "Set2", name = "Intended Vote", labels = c("0" = "No", "1" = "Yes")) +
  labs(x = "Intended Vote", y = "Mean Env", title = "Mean and SE of Env by Intended Vote, Faceted by Wave") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5))

ggsave(here::here("plot","H1_0.6","mean_env_wave_vote_all.png"), mean_env_wave_vote_all, width = 10, height = 8, dpi = 300)

# Calculate the mean and standard error for econ by intendedVote and wave
agg_data_econ <- proportions_both_vote_wave %>%
  group_by(wave, intendedVote) %>%
  summarise(mean_econ = mean(econ), se_econ = sd(econ) / sqrt(n()), .groups = 'drop')

# Plot for econ with mean and SE
mean_econ_wave_vote_all <- ggplot(proportions_both_vote_wave, aes(x = factor(intendedVote), y = econ, fill = factor(intendedVote))) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(width = 0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(width = 0.8), width = 0.25) +
  geom_text(data = agg_data_econ, aes(x = factor(intendedVote), y = mean_econ + se_econ, label = sprintf("%.2f (%.2f)", mean_econ, se_econ)), 
            position = position_dodge(width = 0.8), vjust = -0.5, check_overlap = TRUE) +
  facet_wrap(~wave) +
  scale_fill_brewer(palette = "Set2", name = "Intended Vote", labels = c("0" = "No", "1" = "Yes")) +
  labs(x = "Intended Vote", y = "Mean Econ", title = "Mean and SE of Econ by Intended Vote, Faceted by Wave") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5))

ggsave(here::here("plot","H1_0.6","mean_econ_wave_vote_all.png"), mean_econ_wave_vote_all, width = 10, height = 8, dpi = 300)
```

```{r}
#Plotting mean and SE by wave & vote for all participants

# Define the mean_se function if it's not already defined
mean_se <- function(x) {
  se <- sd(x) / sqrt(length(x))
  return(c(y = mean(x), ymin = mean(x) - se, ymax = mean(x) + se))
}

# Calculate the mean and standard error for env by intendedVote and wave
agg_data_env_cons <- proportions_both_vote_wave_cons %>%
  group_by(wave, intendedVote) %>%
  summarise(mean_env = mean(env), se_env = sd(env) / sqrt(n()), .groups = 'drop')

# Plot for env with mean and SE
mean_env_wave_vote_cons <- ggplot(proportions_both_vote_wave_cons, aes(x = factor(intendedVote), y = env, fill = factor(intendedVote))) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(width = 0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(width = 0.8), width = 0.25) +
  geom_text(data = agg_data_env_cons, aes(x = factor(intendedVote), y = mean_env + se_env, label = sprintf("%.2f (%.2f)", mean_env, se_env)), 
            position = position_dodge(width = 0.8), vjust = -0.5, check_overlap = TRUE) +
  facet_wrap(~wave) +
  scale_fill_brewer(palette = "Set2", name = "Intended Vote", labels = c("0" = "No", "1" = "Yes")) +
  labs(x = "Intended Vote", y = "Mean Env", title = "Mean and SE of Env by Intended Vote, Faceted by Wave for Consistent Participants") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5))

ggsave(here::here("plot","H1_0.6","mean_env_wave_vote_cons.png"), mean_env_wave_vote_cons, width = 10, height = 8, dpi = 300)

# Calculate the mean and standard error for econ by intendedVote and wave
agg_data_econ_cons <- proportions_both_vote_wave_cons %>%
  group_by(wave, intendedVote) %>%
  summarise(mean_econ = mean(econ), se_econ = sd(econ) / sqrt(n()), .groups = 'drop')

# Plot for econ with mean and SE
mean_econ_wave_vote_cons <- ggplot(proportions_both_vote_wave_cons, aes(x = factor(intendedVote), y = econ, fill = factor(intendedVote))) +
  stat_summary(fun = mean, geom = "bar", position = position_dodge(width = 0.8), width = 0.7) +
  stat_summary(fun.data = mean_se, geom = "errorbar", position = position_dodge(width = 0.8), width = 0.25) +
  geom_text(data = agg_data_econ_cons, aes(x = factor(intendedVote), y = mean_econ + se_econ, label = sprintf("%.2f (%.2f)", mean_econ, se_econ)), 
            position = position_dodge(width = 0.8), vjust = -0.5, check_overlap = TRUE) +
  facet_wrap(~wave) +
  scale_fill_brewer(palette = "Set2", name = "Intended Vote", labels = c("0" = "No", "1" = "Yes")) +
  labs(x = "Intended Vote", y = "Mean Econ", title = "Mean and SE of Econ by Intended Vote, Faceted by Wave for Consistent Participants") +
  theme_minimal() +
  theme(legend.position = "bottom",
        axis.title.x = element_text(size = 12, face = "bold"),
        axis.title.y = element_text(size = 12, face = "bold"),
        plot.title = element_text(size = 14, face = "bold", hjust = 0.5))

ggsave(here::here("plot","H1_0.6","mean_econ_wave_vote_cons.png"), mean_econ_wave_vote_cons, width = 10, height = 8, dpi = 300)
```

```{r}
# Checking normality for the 'econ' proportion
shapiro.test(proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote == 0])
shapiro.test(proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote == 1])

shapiro.test(proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote == 0])
shapiro.test(proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote == 1])
```

```{r}
# Wilcoxon signed-rank test for econ overall
econ_test_overall <- wilcox.test(proportions_both_vote_wave$econ[proportions_both_vote_wave$wave=="t1"], proportions_both_vote_wave$econ[proportions_both_vote_wave$wave=="t2"], paired = TRUE)

env_test_overall <- wilcox.test(proportions_both_vote_wave$env[proportions_both_vote_wave$wave=="t1"], proportions_both_vote_wave$env[proportions_both_vote_wave$wave=="t2"], paired = TRUE)

rest_test_overall <- wilcox.test(proportions_both_vote_wave$rest[proportions_both_vote_wave$wave=="t1"], proportions_both_vote_wave$rest[proportions_both_vote_wave$wave=="t2"], paired = TRUE)

print(list(
  econ_test_overall = econ_test_overall,
  env_test_overall = env_test_overall,
  rest_test_overall = rest_test_overall
))

#Econ significantly changes across voters over time

wilcox_effsize(proportions_both_vote_wave, econ~wave,paired=T)
#r=0.17

# Extract econ values for t1 and t2
econ_t1 <- proportions_both_vote_wave$econ[proportions_both_vote_wave$wave == "t1"]
econ_t2 <- proportions_both_vote_wave$econ[proportions_both_vote_wave$wave == "t2"]

# Calculate differences
econ_differences <- econ_t2 - econ_t1

# Calculate the median difference
median_difference <- median(econ_differences, na.rm = TRUE)

# Display the median difference
median_difference
```

```{r}
#Checking Symmetry assumption for signed-rank test
# Assuming proportions_both_vote_wave is your data frame and econ/env are your variables
# Calculate differences between t1 and t2 for econ and env
differences_econ <- proportions_both_vote_wave$econ[proportions_both_vote_wave$wave == "t1"] - 
                    proportions_both_vote_wave$econ[proportions_both_vote_wave$wave == "t2"]

differences_env <- proportions_both_vote_wave$env[proportions_both_vote_wave$wave == "t1"] - 
                   proportions_both_vote_wave$env[proportions_both_vote_wave$wave == "t2"]

# Visual inspection using histograms
par(mfrow=c(2,1)) # Plotting two plots in one window
hist(differences_econ, main="Differences in Econ", xlab="Difference", breaks=20)
hist(differences_env, main="Differences in Env", xlab="Difference", breaks=20)
#looks good
```


```{r}
#Boxplots & paired data of t1 & t2 across voters
# Ensure proportions_both_vote_wave is in the correct format
proportions_long <- proportions_both_vote_wave %>%
  pivot_longer(cols = c(env, econ), names_to = "measure", values_to = "value") %>%
  mutate(id_wave = interaction(participantID, wave))

# Plot for env
ggplot(filter(proportions_long, measure == "env"), aes(x = wave, y = value, group = participantID)) + 
  geom_boxplot(aes(group = wave), fill = c("#56B4E9", "#E69F00"), alpha = 0.5, outlier.shape = NA) +
  geom_point(aes(color = wave), position = position_dodge(width = 0.5)) +
  geom_line(aes(group = participantID), alpha = 0.5) +
  labs(title = "Changes in Env from T1 to T2", y = "Env Value", x = "") +
  scale_color_manual(values = c("t1" = "#56B4E9", "t2" = "#E69F00")) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 0.5))

# Plot for econ
ggplot(filter(proportions_long, measure == "econ"), aes(x = wave, y = value, group = participantID)) + 
  geom_boxplot(aes(group = wave), fill = c("#56B4E9", "#E69F00"), alpha = 0.5, outlier.shape = NA) +
  geom_point(aes(color = wave), position = position_dodge(width = 0.5)) +
  geom_line(aes(group = participantID), alpha = 0.5) +
  labs(title = "Changes in Econ from T1 to T2", y = "Econ Value", x = "") +
  scale_color_manual(values = c("t1" = "#56B4E9", "t2" = "#E69F00")) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, vjust = 0.5))
```
```{r}
#Boxplot of t1 and t2 across voters
# Assuming proportions_both_vote_wave is already prepared
data_long <- proportions_both_vote_wave %>%
  pivot_longer(cols = c(env, econ), names_to = "variable", values_to = "value") %>%
  filter(wave %in% c("t1", "t2"))

# Calculate medians
medians <- data_long %>%
  group_by(wave, variable) %>%
  summarise(median_value = median(value), .groups = 'drop')

# Plot for 'env' including medians
paired_wilcox_across_env <- ggplot(filter(data_long, variable == "env"), aes(x = wave, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.5, outlier.shape = NA) +
  geom_text(data = filter(medians, variable == "env"), aes(x = wave, y = median_value, label = round(median_value, 2)), vjust = -0.5) +
  labs(title = "Env across T1 and T2", x = "Time Point", y = "Env Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5),
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"))

ggsave(here::here("plot","H1_0.6","paired_wilcox_across_env.png"), paired_wilcox_across_env, width = 10, height = 8, dpi = 300)


# Plot for 'econ' including medians
paired_wilcox_across_econ <- ggplot(filter(data_long, variable == "econ"), aes(x = wave, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.5, outlier.shape = NA) +
  geom_text(data = filter(medians, variable == "econ"), aes(x = wave, y = median_value, label = round(median_value, 2)), vjust = -0.5) +
  labs(title = "Econ across T1 and T2", x = "Time Point", y = "Econ Value") +
  geom_text(aes(x = 1.5, y = Inf, label = "Significant change (r = 0.17)"), vjust = 2, hjust = 0.5) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5),
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12, face = "bold"))

ggsave(here::here("plot","H1_0.6","paired_wilcox_across_econ.png"), paired_wilcox_across_econ, width = 10, height = 8, dpi = 300)
```


```{r}
#For wilcoxon signed-rank test, there have to be equal number of values in t1 and t2 for separate votes, so we can only include participants that did not change their vote.

#So these results are only for participants that did not change vote!

# Creating df with consistent participants that were present in both waves with proportions per category, wave, and vote
proportions_wave_cons <- energyact_fin_consistent %>%
  group_by(participantID, wave) %>%
  count(category) %>%
  ungroup() %>%
  group_by(participantID, wave) %>%
  mutate(total = sum(n)) %>%
  ungroup() %>%
  mutate(proportion = n / total) %>%
  select(participantID, wave, category, proportion)

# Pivot wider to have separate columns for each category, filling missing categories with zeros
proportions_category_separate_cons <- proportions_wave_cons %>%
  pivot_wider(names_from = category, values_from = proportion, values_fill = list(proportion = 0))

# Ensure joining with intendedVote to include it in the dataset
proportions_both_vote_wave_cons <- energyact_fin_consistent %>%
  select(participantID, wave, intendedVote) %>%
  distinct() %>%
  left_join(proportions_category_separate_cons, by = c("participantID", "wave"))

# Wilcoxon signed-rank test separate for yes and no voters
data_vote_0 <- filter(proportions_both_vote_wave_cons, intendedVote == 0)
data_vote_1 <- filter(proportions_both_vote_wave_cons, intendedVote == 1)

#Intendedvote=0
env_test_0 <- wilcox.test(data_vote_0$env[data_vote_0$wave=="t1"], data_vote_0$env[data_vote_0$wave=="t2"], paired = TRUE)
econ_test_0 <- wilcox.test(data_vote_0$econ[data_vote_0$wave=="t1"], data_vote_0$econ[data_vote_0$wave=="t2"], paired = TRUE)

# IntendedVote = 1
env_test_1 <- wilcox.test(data_vote_1$env[data_vote_1$wave=="t1"], data_vote_1$env[data_vote_1$wave=="t2"], paired = TRUE)
econ_test_1 <- wilcox.test(data_vote_1$econ[data_vote_1$wave=="t1"], data_vote_1$econ[data_vote_1$wave=="t2"], paired = TRUE)

print(list(
  env_test_0 = env_test_0,
  econ_test_0 = econ_test_0,
  env_test_1 = env_test_1,
  econ_test_1 = econ_test_1
))

#env & econ for no voters only significant at 0.1 level
```

```{r}
# Function adjusted to extract n directly from the test inputs
create_signed_rank_test_row <- function(test_result, variable_name, group_name) {
  n <- length(test_result$data) / 2 # Since data is a concatenated list of both groups
  v_statistic <- test_result$statistic
  p_value <- test_result$p.value
  
  # Return a tibble row
  tibble(
    Variable = variable_name,
    Group = group_name,
    N = n,
    V = v_statistic,
    P_Value = p_value
  )
}

# Assuming data_vote_0 and data_vote_1 are predefined data frames for IntendedVote=0 and IntendedVote=1
# Applying the function to each test result
rows <- list(
  create_signed_rank_test_row(econ_test_overall, "Econ", "Overall"),
  create_signed_rank_test_row(env_test_overall, "Env", "Overall"),
  create_signed_rank_test_row(env_test_0, "Env", "IntendedVote=0"),
  create_signed_rank_test_row(econ_test_0, "Econ", "IntendedVote=0"),
  create_signed_rank_test_row(env_test_1, "Env", "IntendedVote=1"),
  create_signed_rank_test_row(econ_test_1, "Econ", "IntendedVote=1")
)

# Combining all rows into one table
results_table <- bind_rows(rows)

# Printing the results table
print(results_table)
```

```{r}
#Plotting difference histograms to check symmetry assumption of signed-rank tests
# Assuming that 'proportions_both_vote_wave_cons' is your dataframe
# and that 'env' and 'econ' are the names of the variables of interest.

# Calculate the differences for 'env' and 'econ' between t1 and t2 for IntendedVote = 0
env_diff_0 <- with(subset(proportions_both_vote_wave_cons, intendedVote == 0),
                  env[wave == "t1"] - env[wave == "t2"])
econ_diff_0 <- with(subset(proportions_both_vote_wave_cons, intendedVote == 0),
                   econ[wave == "t1"] - econ[wave == "t2"])

# Calculate the differences for 'env' and 'econ' between t1 and t2 for IntendedVote = 1
env_diff_1 <- with(subset(proportions_both_vote_wave_cons, intendedVote == 1),
                  env[wave == "t1"] - env[wave == "t2"])
econ_diff_1 <- with(subset(proportions_both_vote_wave_cons, intendedVote == 1),
                   econ[wave == "t1"] - econ[wave == "t2"])

# Plot the histograms
par(mfrow=c(2,2)) # Setting up the plotting area for 4 plots

# Plotting for IntendedVote = 0
hist(env_diff_0, main="Differences in Env (Vote=0)", xlab="Difference", col="gray")
hist(econ_diff_0, main="Differences in Econ (Vote=0)", xlab="Difference", col="gray")

# Plotting for IntendedVote = 1
hist(env_diff_1, main="Differences in Env (Vote=1)", xlab="Difference", col="gray")
hist(econ_diff_1, main="Differences in Econ (Vote=1)", xlab="Difference", col="gray")
```


```{r}
# Transform data to long format for easier plotting
data_long <- proportions_both_vote_wave_cons %>%
  pivot_longer(cols = c(env, econ), names_to = "variable", values_to = "value") %>%
  mutate(wave_variable = interaction(wave, variable, sep = "_"))

# Calculate medians
medians <- data_long %>%
  group_by(intendedVote, wave, variable, wave_variable) %>%
  summarise(median_value = median(value), .groups = 'drop') %>%
  mutate(median_label = round(median_value, 2))

# Plot for 'env' for no voters (intendedVote == 0) including medians
paired_wilcox_no_env <- ggplot(filter(data_long, intendedVote == 0 & variable == "env"), aes(x = wave_variable, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.7) +
  geom_text(data = filter(medians, intendedVote == 0 & variable == "env"), 
            aes(x = wave_variable, y = median_value, label = median_label), vjust = -0.5) +
  labs(title = "Env for No Voters (T1 vs T2)", x = "", y = "Env Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

ggsave(here::here("plot","H1_0.6","paired_wilcox_no_env.png"), paired_wilcox_no_env, width = 10, height = 8, dpi = 300)

# Plot for 'env' for yes voters (intendedVote == 1) including medians
paired_wilcox_yes_env <- ggplot(filter(data_long, intendedVote == 1 & variable == "env"), aes(x = wave_variable, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.7) +
  geom_text(data = filter(medians, intendedVote == 1 & variable == "env"), 
            aes(x = wave_variable, y = median_value, label = median_label), vjust = -0.5) +
  labs(title = "Env for Yes Voters (T1 vs T2)", x = "", y = "Env Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

ggsave(here::here("plot","H1_0.6","paired_wilcox_yes_env.png"), paired_wilcox_yes_env, width = 10, height = 8, dpi = 300)

# Plot for 'econ' for no voters (intendedVote == 0) including medians
paired_wilcox_no_econ <- ggplot(filter(data_long, intendedVote == 0 & variable == "econ"), aes(x = wave_variable, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.7) +
  geom_text(data = filter(medians, intendedVote == 0 & variable == "econ"), 
            aes(x = wave_variable, y = median_value, label = median_label), vjust = -0.5) +
  labs(title = "Econ for No Voters (T1 vs T2)", x = "", y = "Econ Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

ggsave(here::here("plot","H1_0.6","paired_wilcox_no_econ.png"), paired_wilcox_no_econ, width = 10, height = 8, dpi = 300)

# Plot for 'econ' for yes voters (intendedVote == 1) including medians
paired_wilcox_yes_econ <- ggplot(filter(data_long, intendedVote == 1 & variable == "econ"), aes(x = wave_variable, y = value)) + 
  geom_boxplot(fill = c("#56B4E9", "#E69F00"), alpha = 0.7) +
  geom_text(data = filter(medians, intendedVote == 1 & variable == "econ"), 
            aes(x = wave_variable, y = median_value, label = median_label), vjust = -0.5) +
  labs(title = "Econ for Yes Voters (T1 vs T2)", x = "", y = "Econ Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

ggsave(here::here("plot","H1_0.6","paired_wilcox_yes_econ.png"), paired_wilcox_yes_econ, width = 10, height = 8, dpi = 300)
```


```{r}
#Differences between-subject (vote) across time and for t1 & t2
#econ
wilcox.test(proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote==0],proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote==1],alternative="greater", conf.int = T)
#env
wilcox.test(proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote==1],proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote==0],alternative="greater", conf.int = T)

#Filter waves
data_t1_all <- filter(proportions_both_vote_wave, wave == "t1")
data_t2_all <- filter(proportions_both_vote_wave, wave == "t2")

# Wilcoxon Rank Sum Test for t1
#econ t1
wilcox.test(data_t1_all$econ[data_t1_all$intendedVote==0],data_t1_all$econ[data_t1_all$intendedVote==1],alternative="greater", conf.int = T)

#env t1
wilcox.test(data_t1_all$env[data_t1_all$intendedVote==1],data_t1_all$env[data_t1_all$intendedVote==0],alternative="greater", conf.int = T)

# Wilcoxon Rank Sum Test for t2
#econ t2
wilcox.test(data_t2_all$econ[data_t2_all$intendedVote==0],data_t2_all$econ[data_t2_all$intendedVote==1],alternative="greater", conf.int = T)

#env t2
wilcox.test(data_t2_all$env[data_t2_all$intendedVote==1],data_t2_all$env[data_t2_all$intendedVote==0],alternative="greater", conf.int = T)

#No significant differences between voters in t1
#significant differences in env between voters in t2

#Effect sizes
wilcox_effsize(proportions_both_vote_wave, env~intendedVote, ref.group = "1",detailed=T,alternative="greater")

wilcox_effsize(data_t1_all, env~intendedVote, ref.group = "1",detailed=T,alternative="greater")

wilcox_effsize(data_t2_all, env~intendedVote, ref.group = "1",detailed=T,alternative="greater")
```
```{r}
# Adjusted function to include n1 and n2
calculate_rank_sums <- function(group1, group2, variable_name) {
  test_result <- wilcox.test(group1, group2, alternative="greater", conf.int = TRUE)
  w_statistic <- test_result$statistic
  n1 <- length(group1)
  n2 <- length(group2)
  total_rank_sum <- (n1 + n2) * (n1 + n2 + 1) / 2
  rank_sum_group1 <- w_statistic
  rank_sum_group2 <- total_rank_sum - w_statistic
  # Return a dataframe row
  tibble(
    Variable = variable_name,
    n1 = n1,
    n2 = n2,
    Rank_Sum_Group_1 = rank_sum_group1,
    Rank_Sum_Group_2 = rank_sum_group2,
    P_Value = test_result$p.value
  )
}

# List of test cases
test_cases <- list(
  econ_all = list(group1 = proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote==0],
                  group2 = proportions_both_vote_wave$econ[proportions_both_vote_wave$intendedVote==1],
                  name = "Econ All"),
  env_all = list(group1 = proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote==1],
                 group2 = proportions_both_vote_wave$env[proportions_both_vote_wave$intendedVote==0],
                 name = "Env All"),
  econ_t1 = list(group1 = data_t1_all$econ[data_t1_all$intendedVote==0],
                 group2 = data_t1_all$econ[data_t1_all$intendedVote==1],
                 name = "Econ T1"),
  env_t1 = list(group1 = data_t1_all$env[data_t1_all$intendedVote==1],
                group2 = data_t1_all$env[data_t1_all$intendedVote==0],
                name = "Env T1"),
  econ_t2 = list(group1 = data_t2_all$econ[data_t2_all$intendedVote==0],
                 group2 = data_t2_all$econ[data_t2_all$intendedVote==1],
                 name = "Econ T2"),
  env_t2 = list(group1 = data_t2_all$env[data_t2_all$intendedVote==1],
                group2 = data_t2_all$env[data_t2_all$intendedVote==0],
                name = "Env T2")
)

# Applying the function to each test case and combining results
results_table <- bind_rows(lapply(test_cases, function(case) {
  calculate_rank_sums(case$group1, case$group2, case$name)
}))

# Printing the results table
print(results_table)
```


```{r}
# Calculate median values for 'env' across all time points, T1, and T2
medians_env_all <- proportions_both_vote_wave %>%
  group_by(intendedVote) %>%
  summarise(median_env = round(median(env), 2), .groups = 'drop')

medians_env_t1 <- filter(proportions_both_vote_wave, wave == "t1") %>%
  group_by(intendedVote) %>%
  summarise(median_env = round(median(env), 2), .groups = 'drop')

medians_env_t2 <- filter(proportions_both_vote_wave, wave == "t2") %>%
  group_by(intendedVote) %>%
  summarise(median_env = round(median(env), 2), .groups = 'drop')

# Define a custom color palette
custom_colors <- c("#56B4E9", "#E69F00")

# Plot for 'env' across time points including medians
between_wilcox_env_across <- ggplot(proportions_both_vote_wave, aes(x = factor(intendedVote), y = env, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_env_all, aes(x = factor(intendedVote), y = median_env, label = median_env), vjust = -0.5, color = "black") +
  labs(title = "Env Across Time Points for Yes and No Voters", x = "Intended Vote", y = "Env Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors) +
  geom_text(aes(x = 1.5, y = max(env, na.rm = TRUE), label = "Significant difference for env (r = 0.15)"), vjust = 2, hjust = 0.5)

ggsave(here::here("plot","H1_0.6","between_wilcox_env_across.png"), between_wilcox_env_across, width = 10, height = 8, dpi = 300)

# Plot for 'env' at T1 including medians
between_wilcox_env_t1 <- ggplot(filter(proportions_both_vote_wave, wave == "t1"), aes(x = factor(intendedVote), y = env, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_env_t1, aes(x = factor(intendedVote), y = median_env, label = median_env), vjust = -0.5, color = "black") +
  labs(title = "Env at T1 for Yes and No Voters", x = "Intended Vote", y = "Env Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors)

ggsave(here::here("plot","H1_0.6","between_wilcox_env_t1.png"), between_wilcox_env_t1, width = 10, height = 8, dpi = 300)

# Plot for 'env' at T2 including medians and noting significant difference
between_wilcox_env_t2 <- ggplot(filter(proportions_both_vote_wave, wave == "t2"), aes(x = factor(intendedVote), y = env, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_env_t2, aes(x = factor(intendedVote), y = median_env, label = median_env), vjust = -0.5, color = "black") +
  labs(title = "Env at T2 for Yes and No Voters", x = "Intended Vote", y = "Env Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors) +
  geom_text(aes(x = 1.5, y = max(env, na.rm = TRUE), label = "Significant difference for env at T2 (r = 0.2)"), vjust = 2, hjust = 0.5)

ggsave(here::here("plot","H1_0.6","between_wilcox_env_t2.png"), between_wilcox_env_t2, width = 10, height = 8, dpi = 300)

```

```{r}
# Calculate median values for 'econ' across all time points, T1, and T2
medians_econ_all <- proportions_both_vote_wave %>%
  group_by(intendedVote) %>%
  summarise(median_econ = round(median(econ), 2), .groups = 'drop')

medians_econ_t1 <- filter(proportions_both_vote_wave, wave == "t1") %>%
  group_by(intendedVote) %>%
  summarise(median_econ = round(median(econ), 2), .groups = 'drop')

medians_econ_t2 <- filter(proportions_both_vote_wave, wave == "t2") %>%
  group_by(intendedVote) %>%
  summarise(median_econ = round(median(econ), 2), .groups = 'drop')

# Define custom color palette
custom_colors <- c("#56B4E9", "#E69F00")

# Plot for 'econ' across time points including medians
between_wilcox_econ_across <- ggplot(proportions_both_vote_wave, aes(x = factor(intendedVote), y = econ, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_econ_all, aes(x = factor(intendedVote), y = median_econ, label = median_econ), vjust = -0.5, color = "black") +
  labs(title = "Econ Across Time Points for Yes and No Voters", x = "Intended Vote", y = "Econ Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors)

ggsave(here::here("plot","H1_0.6","between_wilcox_econ_across.png"), between_wilcox_econ_across, width = 10, height = 8, dpi = 300)


# Plot for 'econ' at T1 including medians
between_wilcox_econ_t1 <- ggplot(filter(proportions_both_vote_wave, wave == "t1"), aes(x = factor(intendedVote), y = econ, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_econ_t1, aes(x = factor(intendedVote), y = median_econ, label = median_econ), vjust = -0.5, color = "black") +
  labs(title = "Econ at T1 for Yes and No Voters", x = "Intended Vote", y = "Econ Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors)

ggsave(here::here("plot","H1_0.6","between_wilcox_econ_t1.png"), between_wilcox_econ_t1, width = 10, height = 8, dpi = 300)

# Plot for 'econ' at T2 including medians
between_wilcox_econ_t2 <- ggplot(filter(proportions_both_vote_wave, wave == "t2"), aes(x = factor(intendedVote), y = econ, fill = factor(intendedVote))) + 
  geom_boxplot() +
  geom_text(data = medians_econ_t2, aes(x = factor(intendedVote), y = median_econ, label = median_econ), vjust = -0.5, color = "black") +
  labs(title = "Econ at T2 for Yes and No Voters", x = "Intended Vote", y = "Econ Value") +
  theme_minimal() +
  theme(legend.title = element_blank()) +
  scale_fill_manual(values = custom_colors)

ggsave(here::here("plot","H1_0.6","between_wilcox_econ_t2.png"), between_wilcox_econ_t2, width = 10, height = 8, dpi = 300)
``` 

```{r}
#logistic regression with mean across waves with participants that are present in both waves
# Assuming energyact_fin_summary contains the mean proportions and intendedVote
#Including participants that changed vote

energyact_fin_summary$fintendedVote <- factor(energyact_fin_summary$intendedVote)

# Logistic regression
model_all <- glmer(fintendedVote ~ econ + env + (1 | participantID),
                   family = binomial, data = energyact_fin_summary)

# Display the summary of the adjusted model
summary(model_all)
#Odds Ratio Env
# Extract fixed effects coefficients directly from the model object
fixed_effects <- coef(model_all)$participantID[["(Intercept)"]]

# Extract the coefficient for env_mean
env_coef <- fixef(model_all)["env"]

# Calculate the odds ratio for env_mean
env_or <- exp(env_coef)

# Print the odds ratio
print(paste("Odds ratio of Env =", env_or))
per_word_or <- env_or^0.125
print(paste("Odds ratio of Env per word change (1/8) =", per_word_or))

#Env significantly predicts intendedVote
#Odds ratio of Env = 7.59
#Odds ratio per word change (assuming average of 8 words) = 1.29 = 29% increase in likelihood to vote yes per env word
```

```{r}
# Conducting the regression without random effects
model_all_glm <- glm(fintendedVote ~ econ + env,
                     family = binomial, data = energyact_fin_summary)

# Displaying the summary of the model
summary_model <- summary(model_all_glm)

# Calculate the 95% confidence intervals for the estimates
ci <- confint.default(model_all_glm)

# Add the confidence intervals to the summary table
summary_model$coefficients <- cbind(summary_model$coefficients, "Lower 95% CI" = ci[, 1], "Upper 95% CI" = ci[, 2])

# Display the summary with confidence intervals
print(summary_model)

# Calculate and print the odds ratio for 'env'
odds_ratio_env <- exp(coef(model_all_glm)["env"])
print(paste("Odds ratio of Env =", odds_ratio_env))

# Calculate the odds ratio per word change (1/8)
per_word_or <- odds_ratio_env^0.125
print(paste("Odds ratio of Env per word change (1/8) =", per_word_or))

```
```{r}
# Adding squared terms for continuous predictors
energyact_fin_summary$econ_squared <- energyact_fin_summary$econ^2
energyact_fin_summary$env_squared <- energyact_fin_summary$env^2

# Fit the model including squared terms
model_with_squared_terms <- glm(fintendedVote ~ econ + env + econ_squared + env_squared,
                                family = binomial, data = energyact_fin_summary)

# Check the summary for significance of squared terms
summary(model_with_squared_terms)

#Check Multicollinearity; VIF < 5 is ok
vif(model_all_glm)

# Plot to identify influential cases
par(mfrow = c(2, 2))
plot(model_all_glm)
```

```{r}
# Fit the logistic regression model
model_all_glm <- glm(intendedVote ~ econ + env,
                     family = binomial, data = energyact_fin_summary)

# Get the fitted probabilities
energyact_fin_summary$fitted_probs <- predict(model_all_glm, type = "response")

# Convert probabilities to log-odds
energyact_fin_summary$log_odds <- log(energyact_fin_summary$fitted_probs / (1 - energyact_fin_summary$fitted_probs))

# Create a scatter plot for 'econ' with a smooth line
ggplot(energyact_fin_summary, aes(x = econ, y = log_odds)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", color = "red") +
  labs(title = "Log-Odds vs Econ", x = "Economic Predictor", y = "Log-Odds of Intended Vote")

# Create a scatter plot for 'env' with a smooth line
ggplot(energyact_fin_summary, aes(x = env, y = log_odds)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "loess", color = "red") +
  labs(title = "Log-Odds vs Env", x = "Environmental Predictor", y = "Log-Odds of Intended Vote")
```

```{r}
# Calculate predicted probabilities
predicted_probabilities <- predict(model_all_glm, type = "response")

# Calculate the ROC curve
roc_curve <- roc(energyact_fin_summary$fintendedVote, predicted_probabilities)

# Calculate the AUC
auc_value <- auc(roc_curve)
print(paste("Area under the ROC curve (AUC):", auc_value))

# Plot the ROC curve
auc_plot_0.6 <- plot(roc_curve, main="ROC Curve")
abline(a=0, b= 1, col="red")
```

```{r}
#Logistic regression with wave
proportions_both_vote_wave$fwave <- as.factor(proportions_both_vote_wave$wave)

proportions_both_vote_wave$fintendedVote <- as.factor(proportions_both_vote_wave$intendedVote)


# Mixed-effects logistic regression
mixed_model <- glmer(intendedVote ~ econ + env + fwave + (1 | participantID), 
                     family = binomial(link = "logit"), 
                     data = proportions_both_vote_wave)

# Summary of the model
summary(mixed_model)
```








